<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="description" content="Tribute Page to PewDiePie">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link rel="icon" href="img/brofist.jpg" type="image">
  <title>Technical Document Wordpress.org</title>
  <link rel="stylesheet" href="../css/main2.css">
  <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
  <style>
  @media only screen and (max-width: 815px) {

    #navbar ul {
      border: 1px solid;
      height: 207px;
    }

    #navbar {
      background-color: white;
      position: absolute;
      top: 0;
      padding: 0;
      margin: 0;
      width: 100%;
      max-height: 275px;
      border: none;
      z-index: 1;
    }

    #main-doc {
      position: relative;
      margin-left: 0px;
      margin-top: 270px;
    }
  }

  @media only screen and (max-width: 400px) {
    #main-doc {
      margin-left: -10px;
    }

    code {
      margin-left: -20px;
      width: 100%;
      padding: 15px;
      padding-left: 10px;
      padding-right: 45px;
      min-width: 233px;
    }
  }

  </style>
</head>

<body>
  <nav id="navbar">
    <header class="nav-header">GraphQL Documentation
    </header>
    <ul>
      <li><a class="nav-link" href="#Introduction">Introduction</a></li>
      <li><a class="nav-link" href="#Fundamentals">Fundamentals</a></li>
      <li><a class="nav-link" href="#Best_Practices">Best Practices</a></li>
      <li><a class="nav-link" href="#Query_and_Mutations">Query and Mutations</a></li>
      <li><a class="nav-link" href="#Arguments">Arguments</a></li>
      <li><a class="nav-link" href="#Schemas_and_Types">Schemas and Types</a></li>
      <li><a class="nav-link" href="#Type_Language">Type Language</a></li>
      <li><a class="nav-link" href="#Object_Types_and_Fields">Object Types and Fields</a></li>
      <li><a class="nav-link" href="#Reference">Reference</a></li>
      <li><a class="nav-link" href="#Back_to_Home">Back to Home</a></li>
    </ul>
  </nav>
  <main id="main-doc">
    <section class="main-section" id="Introduction">
      <header class="section-header">
        Introduction
      </header>
      <article class="section-article">
        <p>GraphQL is a query language for your API, and a server-side runtime for executing queries by using a type system you define for your data. GraphQL isn't tied to any specific database or storage engine and is instead backed by your existing code and data. A GraphQL service is created by defining types and fields on those types, then providing functions for each field on each type.
        </p>
      </article>
    </section>
    <section class="main-section" id="Fundamentals">
      <header class="section-header">
        Fundamentals
      </header>
      <article class="section-article">
        <p>a GraphQL service that tells us who the logged in user is (me) as well as that user's name might look something like this:
          <li><code>
type Query {
  me: User
}

type User {
  id: ID
  name: String
}
</code></li>
          Along with functions for each field on each type:
          <li><code>
function Query_me(request) {
  return request.auth.user;
}

function User_name(user) {
  return user.getName();
}
</code></li>
          Once a GraphQL service is running (typically at a URL on a web service), it can be sent GraphQL queries to validate and execute. A received query is first checked to ensure it only refers to the types and fields defined, then runs the provided functions to produce a result.
          For example the query:
          <li><code>
{
  me {
    name
  }
}
Could produce the JSON result:

{
  "me": {
    "name": "Luke Skywalker"
  }
}
</code></li>
        </p>
      </article>
    </section>
    <section class="main-section" id="Best_Practices">
      <header class="section-header">
        Best Practices
      </header>
      <article class="section-article">
        <p>The GraphQL specification is intentionally silent on a handful of important issues facing APIs such as dealing with the network, authorization, and pagination. This doesn't mean that there aren't solutions for these issues when using GraphQL, just that they're outside the description about what GraphQL is and instead just common practice.
          The articles in this section should not be taken as gospel, and in some cases may rightfully be ignored in favor of some other approach. Some articles introduce some of the philosophy developed within Facebook around designing and deploying GraphQL services, while others are more tactical suggestions for solving common problems like serving over HTTP and performing authorization.
          Following are brief descriptions of some of the more common best practices and opinionated stances held by GraphQL services, however each article in this section will go into more depth on these and other topics.
          HTTP
          GraphQL is typically served over HTTP via a single endpoint which expresses the full set of capabilities of the service. This is in contrast to REST APIs which expose a suite of URLs each of which expose a single resource. While GraphQL could be used alongside a suite of resource URLs, this can make it harder to use with tools like GraphiQL.
          Read more about this in Serving over HTTP.
          JSON (with GZIP)
          GraphQL services typically respond using JSON, however the GraphQL spec does not require it. JSON may seem like an odd choice for an API layer promising better network performance, however because it is mostly text, it compresses exceptionally well with GZIP.
          It's encouraged that any production GraphQL services enable GZIP and encourage their clients to send the header:
          Accept-Encoding: gzip
          JSON is also very familiar to client and API developers, and is easy to read and debug. In fact, the GraphQL syntax is partly inspired by the JSON syntax.
          Versioning
          While there's nothing that prevents a GraphQL service from being versioned just like any other REST API, GraphQL takes a strong opinion on avoiding versioning by providing the tools for the continuous evolution of a GraphQL schema.
          Why do most APIs version? When there's limited control over the data that's returned from an API endpoint, any change can be considered a breaking change, and breaking changes require a new version. If adding new features to an API requires a new version, then a tradeoff emerges between releasing often and having many incremental versions versus the understandability and maintainability of the API.
          In contrast, GraphQL only returns the data that's explicitly requested, so new capabilities can be added via new types and new fields on those types without creating a breaking change. This has led to a common practice of always avoiding breaking changes and serving a versionless API.
          Nullability
          Most type systems which recognise "null" provide both the common type, and the nullable version of that type, whereby default types do not include "null" unless explicitly declared. However in a GraphQL type system, every field is nullable by default. This is because there are many things which can go awry in a networked service backed by databases and other services. A database could go down, an asynchronous action could fail, an exception could be thrown. Beyond simply system failures, authorization can often be granular, where individual fields within a request can have different authorization rules.
          By defaulting every field to nullable, any of these reasons may result in just that field returned "null" rather than having a complete failure for the request. Instead, GraphQL provides non-null variants of types which make a guarantee to clients that if requested, the field will never return "null". Instead, if an error occurs, the previous parent field will be "null" instead.
          When designing a GraphQL schema, it's important to keep in mind all the problems that could go wrong and if "null" is an appropriate value for a failed field. Typically it is, but occasionally, it's not. In those cases, use non-null types to make that guarantee.
          Pagination
          The GraphQL type system allows for some fields to return lists of values, but leaves the pagination of longer lists of values up to the API designer. There are a wide range of possible API designs for pagination, each of which has pros and cons.
          Typically fields that could return long lists accept arguments "first" and "after" to allow for specifying a specific region of a list, where "after" is a unique identifier of each of the values in the list.
          Ultimately designing APIs with feature-rich pagination led to a best practice pattern called "Connections". Some client tools for GraphQL, such as Relay, know about the Connections pattern and can automatically provide automatic support for client-side pagination when a GraphQL API employs this pattern.
          Read more about this in the article on Pagination.
          Server-side Batching & Caching
          GraphQL is designed in a way that allows you to write clean code on the server, where every field on every type has a focused single-purpose function for resolving that value. However without additional consideration, a naive GraphQL service could be very "chatty" or repeatedly load data from your databases.
          This is commonly solved by a batching technique, where multiple requests for data from a backend are collected over a short period of time and then dispatched in a single request to an underlying database or microservice by using a tool like Facebook's DataLoader.
        </p>
      </article>
    </section>
    <section class="main-section" id="Query_and_Mutations">
      <header class="section-header">
        Query and Mutations
      </header>
      <article class="section-article">
        <p>Fields<br>
          At its simplest, GraphQL is about asking for specific fields on objects. Let's start by looking at a very simple query and the result we get when we run it:
          <li><code>
{
  hero {
    name
  }
}

{
  "data": {
    "hero": {
      "name": "R2-D2"
    }
  }
}
</code></li>
          You can see immediately that the query has exactly the same shape as the result. This is essential to GraphQL, because you always get back what you expect, and the server knows exactly what fields the client is asking for.
          The field name returns a String type, in this case the name of the main hero of Star Wars, "R2-D2".
          Oh, one more thing - the query above is interactive. That means you can change it as you like and see the new result. Try adding an appearsIn field to the hero object in the query, and see the new result.
          In the previous example, we just asked for the name of our hero which returned a String, but fields can also refer to Objects. In that case, you can make a sub-selection of fields for that object. GraphQL queries can traverse related objects and their fields, letting clients fetch lots of related data in one request, instead of making several roundtrips as one would need in a classic REST architecture.
          <li><code>
{
  hero {
    name
    # Queries can have comments!
    friends {
      name
    }
  }
}
</code></li>
          <li><code>
  {
  "data": {
    "hero": {
      "name": "R2-D2",
      "friends": [
        {
          "name": "Luke Skywalker"
        },
        {
          "name": "Han Solo"
        },
        {
          "name": "Leia Organa"
        }
      ]
    }
  }
}
</code></li>
          Note that in this example, the friends field returns an array of items. GraphQL queries look the same for both single items or lists of items, however we know which one to expect based on what is indicated in the schema.
      </article>
    </section>
    <section class="main-section" id="Arguments">
      <header class="section-header">
        Arguments
      </header>
      <article class="section-article">
        <p>If the only thing we could do was traverse objects and their fields, GraphQL would already be a very useful language for data fetching. But when you add the ability to pass arguments to fields, things get much more interesting.
          <li><code>
{
  human(id: "1000") {
    name
    height
  }
}
</code></li>
          <li><code>
{
  "data": {
    "human": {
      "name": "Luke Skywalker",
      "height": 1.72
    }
  }
}
</code></li>
          In a system like REST, you can only pass a single set of arguments - the query parameters and URL segments in your request. But in GraphQL, every field and nested object can get its own set of arguments, making GraphQL a complete replacement for making multiple API fetches. You can even pass arguments into scalar fields, to implement data transformations once on the server, instead of on every client separately.
          <li><code>
{
  human(id: "1000") {
    name
    height(unit: FOOT)
  }
}
</code></li>
          <li><code>
{
  "data": {
    "human": {
      "name": "Luke Skywalker",
      "height": 5.6430448
    }
  }
}
</code></li>
          Arguments can be of many different types. In the above example, we have used an Enumeration type, which represents one of a finite set of options (in this case, units of length, either METER or FOOT). GraphQL comes with a default set of types, but a GraphQL server can also declare its own custom types, as long as they can be serialized into your transport format.
        </p>
      </article>
    </section>
    <section class="main-section" id="Schemas_and_Types">
      <header class="section-header">
        Schemas and Types
      </header>
      <article class="section-article">
        <p>Type System<br>
          On this page, you'll learn all you need to know about the GraphQL type system and how it describes what data can be queried. Since GraphQL can be used with any backend framework or programming language, we'll stay away from implementation-specific details and talk only about the concepts. If you've seen a GraphQL query before, you know that the GraphQL query language is basically about selecting fields on objects. So, for example, in the following query:
          <li><code>
          {
  hero {
    name
    appearsIn
  }
}
</code></li>
          <li><code>
  {
  "data": {
    "hero": {
      "name": "R2-D2",
      "appearsIn": [
        "NEWHOPE",
        "EMPIRE",
        "JEDI"
      ]
    }
  }
}
</code></li>
          We start with a special "root" object
          We select the hero field on that
          For the object returned by hero, we select the name and appearsIn fields
          Because the shape of a GraphQL query closely matches the result, you can predict what the query will return without knowing that much about the server. But it's useful to have an exact description of the data we can ask for - what fields can we select? What kinds of objects might they return? What fields are available on those sub-objects? That's where the schema comes in.
          Every GraphQL service defines a set of types which completely describe the set of possible data you can query on that service. Then, when queries come in, they are validated and executed against that schema.
        </p>
      </article>
    </section>
    <section class="main-section" id="Type_Language">
      <header class="section-header">
        Type Language
      </header>
      <article class="section-article">
        <p>GraphQL services can be written in any language. Since we can't rely on a specific programming language syntax, like JavaScript, to talk about GraphQL schemas, we'll define our own simple language. We'll use the "GraphQL schema language" - it's similar to the query language, and allows us to talk about GraphQL schemas in a language-agnostic way.</p>
      </article>
    </section>
    <section class="main-section" id="Object_Types_and_Fields">
      <header class="section-header">
        Object Types and Fields
      </header>
      <article class="section-article">
        <p>The most basic components of a GraphQL schema are object types, which just represent a kind of object you can fetch from your service, and what fields it has. In the GraphQL schema language, we might represent it like this:
          <li><code>
type Character {
  name: String!
  appearsIn: [Episode!]!
}
</code></li>
          The language is pretty readable, but let's go over it so that we can have a shared vocabulary:
          Character is a GraphQL Object Type, meaning it's a type with some fields. Most of the types in your schema will be object types.
          name and appearsIn are fields on the Character type. That means that name and appearsIn are the only fields that can appear in any part of a GraphQL query that operates on the Character type.
          String is one of the built-in scalar types - these are types that resolve to a single scalar object, and can't have sub-selections in the query. We'll go over scalar types more later.
          String! means that the field is non-nullable, meaning that the GraphQL service promises to always give you a value when you query this field. In the type language, we'll represent those with an exclamation mark.
          [Episode!]! represents an array of Episode objects. Since it is also non-nullable, you can always expect an array (with zero or more items) when you query the appearsIn field. And since Episode! is also non-nullable, you can always expect every item of the array to be an Episode object.</p>
      </article>
    </section>
    <section class="main-section" id="Reference">
      <header class="section-header">
        Reference
      </header>
      <article class="section-article">
        <p>Learn more about documentation in <a href="https://graphql.github.io/learn/">GraphQL</a> website</p>
      </article>
    </section>
    <section class="main-section" id="Back_to_Home">
      <header class="section-header">
        Back to Home
      </header>
      <article class="section-article">
        <p>Let's back to <a href="https://demmyhafiz.github.io/rwd-project">Home</a></p>
      </article>
    </section>
  </main>
  <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</body>

</html>
